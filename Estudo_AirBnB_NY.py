# -*- coding: utf-8 -*-
"""Envio_Airbnb_BeeTech.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aRZDWg4nukGVJuww39zv9ren8Og-1maM
"""

import pandas as pd
import seaborn as sns
import numpy as np

# kaggle.com/dgomonov/new-york-city-airbnb-open-data

airbnb = pd.read_csv('AB_NYC_2019.csv')

"""# Analisando o comportamento das variáveis
## Outliers e NaN

Primeiramente vamos analisar a estrutura da Base, entender se existem valores nulos e quais são esses valores.
"""

airbnb.info()

"""## Questão 2

Verificou-se que a base possui 48.895 registros, porém os campos 'name, host_name', 'last_review' e 'review_per_month', possuem alguns valores missing (null).

Avaliando a documentação da base podemos observar que os valores relacionados ao nome dos usuáriuos pode ser ignorado, uma vez que o 'host_id' pode nos auxiliar na relação das informações por usuário.

As variáveis relacionadas a review precisam de mais análise.
"""

#Vamos começar analisando os reviews_per_month
select = airbnb.reviews_per_month.isna()
n_airbnb = airbnb[select]
n_airbnb.describe()

#Vamos repetir a análise para a ultima avaliação
select = airbnb.last_review.isna()
n2_airbnb = airbnb[select]
n2_airbnb.describe()

"""Podemos avaliar que os casos em que existem valores nulos, são os casos onde ainda não houve avaliação para o imóvel (number_of_reviews = 0).

Como os campos relacionados estão missing, podemos subistituir os NaN por 0 a fim de completar as informações da base. 

Caso as variáveis fossem valores faltantes ao invés de não coletados, poderia fazer uma substituição pela mediana ou uma interpolação pelos resultados visinhos ou semelhantes, o caso aqui encontrado é mais simples.

Vamos também selecionar apenas os campos de interesse, ou seja retirar os campos de nome da base
"""

airbnb.fillna(0, inplace = True)

airbnb.info()

airbnb_limpo = airbnb.drop(columns = ["name", "host_name"], axis=1)

airbnb_limpo.info()

"""## Questão 1

Para começar a analise das variáveis, vamos olhar o comportamento das variáveis usando o *describe*
"""

airbnb_limpo.describe()

"""Agora vamos analisar as variáveis de interesse para verificar valores possivelmente 'ruins', com uma variação muito grande, vamos analisar os dados **preço**, **latitude/longitude** e **número de noites**

### Número de Noites
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt
plt.rc('figure', figsize = (15,10))

airbnb_limpo.boxplot(['minimum_nights'])

airbnb_limpo.minimum_nights.describe()

"""Podemos notar que existem 'outliers' nessa variável, não é de se esperar um máximo de 1250 noites para uma estadia em um Airbnb. 
Vamos fazer uma análise a mais: conhecendo o perfil da base, seria interessante notar se o mínimo de noites pode ter alguma relação com outra variável como tipo de quarto. É de se esperar que para moradias maiores o tempo de estadia possa ser maior. 
Portanto para tratar esses dados vamos fazer a analise considerando a dimensão tipo de quarto também.
"""

airbnb_limpo.boxplot(['minimum_nights'], by = ['room_type'])

"""Vamos utilizar a regra do intervalo interquatílico para limpar os outliers desse campo, em relação ao tipo de quarto, para facilitar a analise."""

grupo_tipo = airbnb_limpo.groupby('room_type')['minimum_nights']
Q1 = grupo_tipo.quantile(.25).round(2)
Q3 = grupo_tipo.quantile(.75).round(2)
IIQ = (Q3 - Q1).round(2)
limite_inferior = (Q1 - 1.5*IIQ).round(2)
limite_superior = (Q3 + 1.5*IIQ).round(2)

dados_minimo_noites = pd.DataFrame()
for tipo in grupo_tipo.groups.keys():
    eh_tipo = airbnb_limpo['room_type'] == tipo
    eh_dentro_limite = (airbnb_limpo['minimum_nights'] >= limite_inferior[tipo]) & (airbnb_limpo['minimum_nights'] <= limite_superior[tipo])
    selecao = eh_tipo & eh_dentro_limite
    dados_selecao = airbnb_limpo[selecao]
    dados_minimo_noites = pd.concat([dados_minimo_noites, dados_selecao])

dados_minimo_noites.boxplot(['minimum_nights'], by = ['room_type'])

dados_minimo_noites.info()

"""Agora com a base limpa, podemos verificar os dados de quantidade minima de noites sem os outliers. E conforme o esperado, tempos um tempo minimo desejado maior para a moradia completa.

### Variável Preço

Vamos realizar a mesma analise para o campo preço, e faremos a mesma tecnica para limpar os outliers caso existam. Assim podemos ter uma visão menos distorcida dos valores.
"""

airbnb_limpo.price.describe()

"""Podemos notar a existência de outliers, não é de se esperar um quarto com o preço zero, ou ainda 10.000 a noite.

Para o caso do preço, é natural que se imagine que os preços médios possam variar por distrito. Portanto, afim de uma analise mais apurada vamos considerar o par price x neighbourhood_group.
"""

airbnb_limpo.boxplot(['price'], by = ['neighbourhood_group'])

"""Manhatam tem o preço mais disperso, o que é de se esperar dado o perfil do local."""

grupo_bairro = airbnb_limpo.groupby('neighbourhood_group')['price']
Q1 = grupo_bairro.quantile(.25).round(2)
Q3 = grupo_bairro.quantile(.75).round(2)
IIQ = (Q3 - Q1).round(2)
LI = (Q1 - 1.5*IIQ).round(2)
LS = (Q3 + 1.5*IIQ).round(2)
bairro_novo_price = pd.DataFrame()
for tipo in grupo_bairro.groups.keys():
    eh_tipo = airbnb['neighbourhood_group'] == tipo
    eh_dentro_limite = (airbnb_limpo['price'] >= LI[tipo]) & (airbnb_limpo['price'] <= LS[tipo])
    selecao = eh_tipo & eh_dentro_limite
    dados_selecao = airbnb_limpo[selecao]
    bairro_novo_price = pd.concat([bairro_novo_price, dados_selecao])

bairro_novo_price.boxplot(['price'], by = ['neighbourhood_group'])

"""### Latitude/Longitude - Coordenadas

Por último vamos analisar as variáveis de latitude e longitude. Para isso, vamos usar a figura do mapa de NYC para auxiliar a plotagem dos pontos.
"""

airbnb_limpo[['latitude', 'longitude']].describe()

plt.figure(figsize=(10,10))
sns.scatterplot(airbnb_limpo.longitude,airbnb_limpo.latitude,hue=airbnb_limpo.neighbourhood_group)
plt.ioff()

# Código utilizando informação do Kagle (desafio - )

import urllib
plt.figure(figsize=(10,10))
i=urllib.request.urlopen('https://upload.wikimedia.org/wikipedia/commons/e/ec/Neighbourhoods_New_York_City_Map.PNG')
nyc_img=plt.imread(i)
#determinar a escala da figura de acordo com os limites de latitude e longitude
plt.imshow(nyc_img,zorder=0,extent=[-74.258, -73.7, 40.49,40.92])
ax=plt.gca()

airbnb_limpo.plot(kind='scatter', x='longitude', y='latitude', label='availability_365', c='price', ax=ax, 
           cmap=plt.get_cmap('jet'), colorbar=True, alpha=0.4, zorder=5)
plt.legend()
plt.show()

"""Pela plotagem das imagens, notamos que não existe dados estranhos nessa variável, ou seja, todas as latitudes e longitudes apontam para pontos reais dentro da cidade de NYC."""



"""# Analises por demografia Distritos

### Questão 3

Para fazer as análises dos dados referentes as regiões e demografia dos distritos de NYC vamos utilizar uma tabela de dados complementar ('https://en.wikipedia.org/wiki/Boroughs_of_New_York_City')
"""

extra = {
    'neighbourhood_group' : ['Bronx','Brooklyn','Manhattan','Queens','Staten Island'],
    'population' : [1471160, 2648771, 1664727, 2358582, 479458],
    'gdp' : [28787, 63303, 629682, 73842, 11249],
    'land_area' : [42.10, 70.82, 22.83, 108.53, 58.37],
    'density' : [34653, 37137, 72033, 21460, 8112]
}
demografia = pd.DataFrame(data=extra)

demografia

distribuicao_distrito = airbnb_limpo.groupby(['neighbourhood_group']).count()['id'].reset_index()

distribuicao_cross = distribuicao_distrito.merge(demografia, how='left')

distribuicao_cross

plt.figure(figsize=(10,10))
sns.scatterplot(x='density', y='id', data=distribuicao_cross)

"""A densidade populacional da região indica ter uma relação direta com a oferta de imóveis. Vamos analisar a distribuição desses imóveis"""

distribuicao_anuncios = airbnb_limpo.groupby(['neighbourhood_group','room_type']).count()['id'].reset_index()

sns.barplot(x='neighbourhood_group', y='id', hue='room_type', data = distribuicao_anuncios)

"""Analisando a oferta pela distribuição dos distritos, podemos notar que os dois distritos com a maior densidade populacional também são os distritos com a maior quantidade de oferta de moradias.

Vamos analisar a proporção da distribiução de tipos de moradia pelo total de oferta do bairro.
"""

distribuicao_anuncios['prop']=distribuicao_anuncios.groupby('neighbourhood_group')['id'].apply(lambda x: x/np.sum(x))

sns.barplot(x='neighbourhood_group', y='prop', hue='room_type', data = distribuicao_anuncios)

"""Conhecendo o perfil dos distritos, é de se imaginar que a oferta de apartamentos inteiros seja maior em Manhatan. Distrito mais central, com moradias menores inviabilizam a divisão da moradia para locação. A oferta de quartos dividios não é muito expressiva em nenhuma região.

# Analise dos Bairros

Agora vamos analisar a distribuição dos bairros mais 'requisitados'. Para isso considerei 3 variáveis para analisar, disponibilidade, total de avaliações e avaliações por mês. Usei um group sort apenas para verificar os 5 mais e os 5 menos requisitados.

### Questão 4
"""

disponibilidade_regiao = airbnb_limpo.groupby(['neighbourhood']).sum()['availability_365'].reset_index()
disponibilidade_regiao.sort_values(by=['availability_365'], ascending = False).head(5)

avaliacoes_por_mes = airbnb_limpo.groupby(['neighbourhood']).sum()['reviews_per_month'].reset_index()
avaliacoes_por_mes.sort_values(by=['reviews_per_month'], ascending = False).head(5)

avaliacoes_por_mes = airbnb_limpo.groupby(['neighbourhood']).sum()['number_of_reviews'].reset_index()
avaliacoes_por_mes.sort_values(by=['number_of_reviews'], ascending = False).head(5)

quantidade_por_host = airbnb_limpo.groupby(['neighbourhood']).sum()['calculated_host_listings_count'].reset_index()
quantidade_por_host.sort_values(by=['calculated_host_listings_count'], ascending = False).head(5)



"""Verificando as tres variáveis, podemos notar que os bairros que tem maior quantidade de avaliações assim como maior disponibilidade sao os mesmos:

**Bedford-Stuyvesant**, **Williamsburg**, **Harlem**, **Bushwick**, **Hell's Kitchen**
"""

avaliacoes_por_mes = airbnb_limpo.groupby(['neighbourhood']).sum()['number_of_reviews'].reset_index()
avaliacoes_por_mes.sort_values(by=['number_of_reviews'], ascending = False).tail(5)

avaliacoes_por_mes = airbnb_limpo.groupby(['neighbourhood']).sum()['reviews_per_month'].reset_index()
avaliacoes_por_mes.sort_values(by=['reviews_per_month'], ascending = False).tail(5)

disponibilidade_regiao = airbnb_limpo.groupby(['neighbourhood']).sum()['availability_365'].reset_index()
disponibilidade_regiao.sort_values(by=['availability_365'], ascending = False).tail(5)

quantidade_por_host = airbnb_limpo.groupby(['neighbourhood']).sum()['calculated_host_listings_count'].reset_index()
quantidade_por_host.sort_values(by=['calculated_host_listings_count'], ascending = False).tail(5)

bairros_menos_procurados = ['Woodrow', 'New Dorp' ,'Bay Terrace, Staten Island', 'Rossville', 'Westerleigh','Co-op City','Breezy Point','Bay Terrace, Staten Island']
selecao = airbnb_limpo['neighbourhood'].isin(bairros_menos_procurados)
airbnb_menors = airbnb[selecao]

plt.figure(figsize=(10,10))
i=urllib.request.urlopen('https://upload.wikimedia.org/wikipedia/commons/e/ec/Neighbourhoods_New_York_City_Map.PNG')
nyc_img=plt.imread(i)
#determinar a escala da figura de acordo com os limites de latitude e longitude
plt.imshow(nyc_img,zorder=0,extent=[-74.258, -73.7, 40.49,40.92])
ax=plt.gca()

airbnb_menors.plot(kind='scatter', x='longitude', y='latitude', label='availability_365', c='price', ax=ax, 
           cmap=plt.get_cmap('jet'), colorbar=True, alpha=0.4, zorder=5)
plt.legend()
plt.show()

bairros_mais_procurados = ['Bedford-Stuyvesant', 'Williamsburg, Harlem', 'Bushwick', "Hell's Kitchen"]
selecao = airbnb_limpo['neighbourhood'].isin(bairros_mais_procurados)
airbnb_majors = airbnb[selecao]

plt.figure(figsize=(10,10))
i=urllib.request.urlopen('https://upload.wikimedia.org/wikipedia/commons/e/ec/Neighbourhoods_New_York_City_Map.PNG')
nyc_img=plt.imread(i)
#determinar a escala da figura de acordo com os limites de latitude e longitude
plt.imshow(nyc_img,zorder=0,extent=[-74.258, -73.7, 40.49,40.92])
ax=plt.gca()

airbnb_majors.plot(kind='scatter', x='longitude', y='latitude', label='availability_365', c='price', ax=ax, 
           cmap=plt.get_cmap('jet'), colorbar=True, alpha=0.4, zorder=5)
plt.legend()
plt.show()

"""Podemos notar que as localizações mais procuradas são localizações com um grande fluxo de turistas (região do brookling revitalizado e manhatan central (midtown)), enquanto regiões periféricas possuem um menor acumulo de oferta.

Considerando que os bairros com maior demanda possuem um maior apelo turístico, poderiamos começar por fazer uma campanha para valorizar as qualidades dos bairros, adicionar pontos turísticos, atrações locais, lugares para se visitar.

Em paralelo, poderíamos incentivar os hosts a convidarem mais hosts bonificando cada cadastro e/ou primeira reserva.

# Hosts com maior faturamento

### Questão 5

Considerando os Hosts, vamos usar o host_id.
Para analisar os hosts com o maior faturamento, devemos analisar algumas variáveis além de preço.
Vamos supor que todos os imóveis tem a mesma taxa de reviews por reserva, ou seja a cada x reservas temos um numero y de reviews.
Se essa taxa for igual para todos os imóveis, podemos considerar que o numero de reviews pode nos dar um estimador de quantas reservas são feitas.
Dessa forma podemos calcular o 'ganho' anual com uma aproximação de preço da oferta pela quantidade de reviews por mês, em 12 meses.
"""

airbnb_limpo['anual_income'] = airbnb_limpo['reviews_per_month']*airbnb_limpo['price']*12

airbnb_host = airbnb_limpo.query('number_of_reviews > 0')

airbnb_host.head()

airbnb_host.describe()

host_anual_income = airbnb_host.groupby(['host_id']).sum()['anual_income'].reset_index()

host_anual_income.sort_values(by=['anual_income'], ascending = False).head(10)

teste_hosts = host_anual_income.sort_values(by=['anual_income'], ascending = False).head(10)['host_id']

teste_hosts

selecao = airbnb_host['host_id'].isin(teste_hosts)
airbnb_value = airbnb_host[selecao]

airbnb_value.describe()[['price','number_of_reviews','calculated_host_listings_count','availability_365']]

plt.figure(figsize=(10,10))
i=urllib.request.urlopen('https://upload.wikimedia.org/wikipedia/commons/e/ec/Neighbourhoods_New_York_City_Map.PNG')
nyc_img=plt.imread(i)
#determinar a escala da figura de acordo com os limites de latitude e longitude
plt.imshow(nyc_img,zorder=0,extent=[-74.258, -73.7, 40.49,40.92])
ax=plt.gca()

airbnb_value.plot(kind='scatter', x='longitude', y='latitude', label='availability_365', c='price', ax=ax, 
           cmap=plt.get_cmap('jet'), colorbar=True, alpha=0.4, zorder=5)
plt.legend()
plt.show()

airbnb_value.describe()[['price','number_of_reviews','calculated_host_listings_count','availability_365']]

airbnb_limpo.describe()[['price','number_of_reviews','calculated_host_listings_count','availability_365']]

"""Podemos notar que os hosts com o **maior faturamento** se encontram na **região de Manhatan**, tem um **valor por imóvel bem acima da média da base**, assim como uma **maior quantidade de imóveis cadastrados**. Aumentando o faturamento.

# Novos Hosts

### Questão 6
"""

airbnb_novos = airbnb_limpo.query('number_of_reviews == 0')

airbnb_novos_mh = airbnb_novos.loc[(airbnb_novos['neighbourhood_group'].astype(str).str.contains("Manhattan"))]

selecao = airbnb_novos_mh['neighbourhood'].isin(bairros_mais_procurados)
airbnb_novos_mh_bairros = airbnb_novos_mh[selecao]

airbnb_novos_mh_bairros =airbnb_novos_mh_bairros.query('calculated_host_listings_count == 1')

airbnb_novos_mh_bairros.describe()

airbnb_novos_mh_bairros =airbnb_novos_mh_bairros.query('availability_365 == 0')

airbnb_novos_mh_bairros.describe()

"""Para analisar os novos hosts, foi considerado os indicadores com **menores índices** dentro dos **bairros mais procurados**.
Hosts nos bairros mais procurados, com **availability = 0**, **sem recomendações**, e com o **número de cadastros igual a 1**, como estão em uma região de grande procura, provavelmente são novos usuários na plataforma.
"""

escolha = [950232, 4022922]

airbnb_novos_mh_bairros

selecao = airbnb['host_id'].isin(escolha)
hosts = airbnb[selecao]

hosts

"""Poderiamos auxiliar os hosts com uma campanha para **tirar boas fotos dos imóveis** com alguns profissionais da área, auxiliar os hosts a se **tornarem superhosts**, auxiliar na **criação de vídeos para divulgação dos benefícios de se hospedar com esses hosts**.
Ainda poderiamos incentivar a **divulgação dos imóveis bonificando os host após a primeira reserva**.
"""